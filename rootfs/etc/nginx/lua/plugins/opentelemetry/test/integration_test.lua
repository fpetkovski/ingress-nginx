------------------------------------------------------------------------------------------------------------------------
-- These tests flex the plugin's functionality by calling each of its phases in sequence, simulating the call from
-- plugins.run.
------------------------------------------------------------------------------------------------------------------------

local response_header_setter = require("plugins.opentelemetry.response_header_setter")
local recording_span = require("opentelemetry.trace.recording_span")
local shopify_utils = require("plugins.opentelemetry.shopify_utils")
local span_context = require "opentelemetry.trace.span_context"
local test_span_processor = require("plugins.opentelemetry.test.test_span_processor")
local test_utils = require("plugins.opentelemetry.test.utils")

------------------------------------------------------------------------------------------------------------------------
-- Make propagation headers based on a span

-- @param[type=table] span Span to make headers from
-- @param[type=string] sampled Whether or not to mark the span as sampled
-- @param[type=string] tracestate The string value of the tracestate header
------------------------------------------------------------------------------------------------------------------------
local function make_propagation_headers(span, sampled, tracestate)
    if not span then
        local new_span_context = span_context.new("b4505bb3d5838de2663cac10341d8aaa", "30e2bb20d2ad42b9", nil, nil, false)
        span = recording_span.new(nil, nil, new_span_context, "test_span", {})
    end
    if sampled == "sampled" then
        sampled = "1"
    else
        sampled = "0"
    end
    local header_value =  span:context().trace_id .. "/" .. shopify_utils.hex_to_decimal_string(span:context().span_id) .. ";o=" .. sampled

    return {
        ["x-shopify-trace-context"] = header_value,
        ["x-cloud-trace-context"] = header_value,
        ["tracestate"] = tracestate or "",
    }
end

------------------------------------------------------------------------------------------------------------------------
-- Extract the first span with a given name from a list of spans
--
-- @param[type=string] name Name of span to find
-- @param[type=table] name Integer indexed table of spans
--
-- @return nil or the span with the given name
------------------------------------------------------------------------------------------------------------------------
local function span_by_name(name, spans)
    for _, v in ipairs(spans) do
        if v.name == name then
            return v
        end
    end

    return nil
end
------------------------------------------------------------------------------------------------------------------------
-- This function simulates a request to the plugin by calling each of its phases in sequence.

-- @param[type=table] config Table of configuration (generated by test_utils.make_config)
-- @param[type=table] request_headers Table of request headers
-- @param[type=table] ngx_var Table that subs in for ngx.var
-- @param[type=table] response_headers Table of response headers from upstream
--
-- @return Table with results.
------------------------------------------------------------------------------------------------------------------------
local function simulate_request(config, request_headers, ngx_var, response_headers_from_upstream)
    config = config or test_utils.make_config()
    ngx_var = ngx_var or test_utils.make_ngx_var()
    ngx.ctx.opentelemetry_plugin_mode = nil
    ngx.ctx.opentelemetry_tracer = nil
    ngx.ctx.opentelemetry = nil
    ngx.ctx.opentelemetry_spans = nil
    ngx.var = ngx_var

    local req_headers_added = {}
    local resp_headers_added = {}

    -- Stub out headers of _inbound_ request
    stub(ngx.req, "get_headers", function()
        return request_headers
    end)

    -- Keep track of headers added to request sent to proxy
    stub(ngx.req, "set_header", function(header, value)
        req_headers_added[header] = value
    end)

    -- Stub out _response headers_ from upstream
    stub(ngx.resp, "get_headers", function() return response_headers_from_upstream or {} end)

    -- Keep track of headers added to response
    stub(response_header_setter, "set", function(_carrier, key, val)
        resp_headers_added[key] = val
    end)

    package.loaded['plugins.opentelemetry.main'] = nil
    local main = require("plugins.opentelemetry.main")
    main.plugin_open_telemetry_span_processor = test_span_processor.new()
    main.init_worker(config)
    main.rewrite()
    main.header_filter()
    main.log()
    local finished_spans = main.plugin_open_telemetry_span_processor:finished_spans()
    ngx.req.get_headers:revert()
    ngx.req.set_header:revert()
    return {
        finished_spans = finished_spans,
        req_headers_added = req_headers_added,
        resp_headers_added = resp_headers_added,
        request_span = span_by_name("nginx.request", finished_spans),
    }
end

describe("bypassed upstreams", function()
    it("does not generate spans if all upstreams are bypassed", function()
        local config = test_utils.make_config({ plugin_open_telemetry_bypassed_upstreams = "all" })
        local result = simulate_request(config, {})
        assert.are_same({}, result.finished_spans)
        assert.are_same({}, result.req_headers_added)
        assert.are_same({}, result.resp_headers_added)
    end)

    it("does not generate spans if specific upstream is bypassed", function()
        local config = test_utils.make_config(
            { plugin_open_telemetry_bypassed_upstreams = "pizza,papa,johns,its-all-technically-pizza" })
        local ngx_var = test_utils.make_ngx_var({ proxy_upstream_name = "pizza" })
        local result = simulate_request(config, {}, ngx_var)
        assert.are_same({}, result.finished_spans)
        assert.are_same({}, result.req_headers_added)
        assert.are_same({}, result.resp_headers_added)
    end)

    it("does not generate spans if upstream partially matches bypassed", function()
        local config = test_utils.make_config({ plugin_open_telemetry_bypassed_upstreams = "pi" })
        local ngx_var = test_utils.make_ngx_var({ proxy_upstream_name = "pizza" })
        local result = simulate_request(config, {}, ngx_var)
        assert.are_same({}, result.finished_spans)
        assert.are_same({}, result.req_headers_added)
        assert.are_same({}, result.resp_headers_added)
    end)
end)

describe("when upstream is in VERBOSITY_SAMPLING mode", function()
    it("extracts and injects context when trace headers are present and parent was sampled", function()
        local trace_id = "11111111d5838de2663cac10341d8945"
        local new_span_context = span_context.new(trace_id, "30e2bb20d2ad42b9", nil, nil, false)
        local span = recording_span.new(nil, nil, new_span_context, "test_span", {})
        local propagation_headers = make_propagation_headers(span, "sampled")
        local result = simulate_request(nil, propagation_headers, nil)
        assert.are_same(1, #result.finished_spans)
        assert.are_same(trace_id, result.request_span:context().trace_id)
        assert.are_same(make_propagation_headers(result.request_span, "sampled"), result.req_headers_added)
        assert.are_same({}, result.resp_headers_added)
    end)

    it("propagates context and emits unsampled spans when trace headers are present and parent was not sampled", function()
        local trace_id = "a1111111d5838de2663cac10341d8945"
        local new_span_context = span_context.new(trace_id, "30e2bb20d2ad42b9", nil, nil, false)
        local span = recording_span.new(nil, nil, new_span_context, "test_span", {})
        local propagation_headers = make_propagation_headers(span, "unsampled")
        local result = simulate_request(nil, propagation_headers, nil)
        for _, sp in ipairs(result.finished_spans) do
            assert.are_same(sp:context():is_sampled(), false)
        end
        assert.are_same(string.sub(result.req_headers_added["x-cloud-trace-context"], 0, 32), span:context().trace_id)
        assert.are_same({}, result.resp_headers_added)
    end)
end)

describe("deferred sampling", function()
    local config = test_utils.make_config({ plugin_open_telemetry_deferred_sampling_upstreams = "all" })

    describe("when trace context headers are not on inbound request", function()
        it("samples out when tracesponse is malformed", function()
            local result = simulate_request(config, {}, nil, { traceresponse = "lalalalalala"})
            assert.are_same(1, #result.finished_spans)
            assert.are_same(make_propagation_headers(result.request_span, "unsampled"), result.req_headers_added)
            for _, v in ipairs(result.finished_spans) do
                assert.is_false(v:context():is_sampled())
            end
            assert.are_same({}, result.resp_headers_added)
        end)

        it("adds context headers but samples out traces when traceresponse is absent", function()
            local result = simulate_request(config, {})
            assert.are_same(1, #result.finished_spans)
            assert.are_same(make_propagation_headers(result.request_span, "unsampled"), result.req_headers_added)
            for _, v in ipairs(result.finished_spans) do
                assert.is_false(v:context():is_sampled())
            end
            assert.are_same({}, result.resp_headers_added)
        end)

        it("adds context headers and samples in traces when traceresponse is present and 01", function()
            local result = simulate_request(
                config, {}, ngx_var, { traceresponse = "00-cdc9d461ab73f5a441fca78f6a970154-562144007775f2ec-01"})
            assert.are_same(1, #result.finished_spans)
            for _, v in ipairs(result.finished_spans) do
                assert.is_true(v:context():is_sampled())
            end
            assert.are_same(make_propagation_headers(result.request_span, "unsampled"), result.req_headers_added)
            assert.are_same({}, result.resp_headers_added)
        end)

        it("adds context headers and samples out traces when traceresponse is present and 00", function()
            local result = simulate_request(
                config, {}, nil, { traceresponse = "00-cdc9d461ab73f5a441fca78f6a970154-562144007775f2ec-00"})
            assert.are_same(1, #result.finished_spans)
            assert.are_same(make_propagation_headers(result.request_span, "unsampled"), result.req_headers_added)

            for _, v in ipairs(result.finished_spans) do
                assert.is_false(v:context():is_sampled())
            end
            assert.are_same({}, result.resp_headers_added)
        end)
    end)

    describe("when trace context headers indicate that upstream was sampled in", function()
        it("samples in and adds context headers when traceresponse is present and 00", function()
            local prop_headers = make_propagation_headers(nil, "sampled")
            local result = simulate_request(
                nil, prop_headers, nil, { traceresponse = "00-cdc9d461ab73f5a441fca78f6a970154-562144007775f2ec-00"})
            assert.are_same(1, #result.finished_spans)
            assert.are_same(make_propagation_headers(result.request_span, "sampled"), result.req_headers_added)
            for _, v in ipairs(result.finished_spans) do
                assert.is_true(v:context():is_sampled())
            end
            assert.are_same({}, result.resp_headers_added)
        end)

        it("samples in and adds context headers when traceresponse is present and 01", function()
            local prop_headers = make_propagation_headers(nil, "sampled")
            local result = simulate_request(
                nil, prop_headers, nil, { traceresponse = "00-cdc9d461ab73f5a441fca78f6a970154-562144007775f2ec-01"})
            assert.are_same(1, #result.finished_spans)
            assert.are_same(make_propagation_headers(result.request_span, "sampled"), result.req_headers_added)

            for _, v in ipairs(result.finished_spans) do
                assert.is_true(v:context():is_sampled())
            end
            assert.are_same({}, result.resp_headers_added)
        end)

        it("samples in and adds context headers when traceresponse is absent", function()
            local prop_headers = make_propagation_headers(nil, "sampled")
            local result = simulate_request(nil, prop_headers, nil, {})
            assert.are_same(1, #result.finished_spans)
            assert.are_same(make_propagation_headers(result.request_span, "sampled"), result.req_headers_added)

            for _, v in ipairs(result.finished_spans) do
                assert.is_true(v:context():is_sampled())
            end
            assert.are_same({}, result.resp_headers_added)
        end)
    end)

    describe("when trace context headers indicate that upstream was sampled out", function()
        it("samples out and adds context headers when traceresponse is present and 00", function()
            local prop_headers = make_propagation_headers(nil, "unsampled")
            local result = simulate_request(
                config, prop_headers, nil, { traceresponse = "00-cdc9d461ab73f5a441fca78f6a970154-562144007775f2ec-00"})
            assert.are_same(1, #result.finished_spans)
            assert.are_same(make_propagation_headers(result.request_span, "unsampled"), result.req_headers_added)

            for _, v in ipairs(result.finished_spans) do
                assert.is_false(v:context():is_sampled())
            end
            assert.are_same({}, result.resp_headers_added)
        end)

        it("samples in and adds context headers when traceresponse is present and 01", function()
            local config = test_utils.make_config({plugin_open_telemetry_record_p = true, plugin_open_telemetry_deferred_sampling_upstreams = "all"})
            local prop_headers = make_propagation_headers(nil, "unsampled")
            local result = simulate_request(
                config, prop_headers, nil, { traceresponse = "00-cdc9d461ab73f5a441fca78f6a970154-562144007775f2ec-01", ["x-shopify-tracesampling-p"] = "63" })
            assert.are_same(1, #result.finished_spans)
            assert.are_same(make_propagation_headers(result.request_span, "unsampled"), result.req_headers_added)

            for _, v in ipairs(result.finished_spans) do
                assert.is_true(v:context():is_sampled())
                assert.are_same("p:63", v:context().trace_state:get("ot"))
            end
            assert.are_same({}, result.resp_headers_added)
        end)

        it("does not update P when response header is absent", function()
            local prop_headers = make_propagation_headers(nil, "unsampled")
            local result = simulate_request(
                config, prop_headers, nil, { traceresponse = "00-cdc9d461ab73f5a441fca78f6a970154-562144007775f2ec-01" })
            assert.are_same(1, #result.finished_spans)
            assert.are_same(make_propagation_headers(result.request_span, "unsampled"), result.req_headers_added)

            for _, v in ipairs(result.finished_spans) do
                assert.is_true(v:context():is_sampled())
                assert.are_equal("", v:context().trace_state:get("ot"))
            end
            assert.are_same({}, result.resp_headers_added)
        end)

        it("samples out and adds context headers when traceresponse is absent", function()
            local prop_headers = make_propagation_headers(nil, "unsampled")
            local result = simulate_request(config, prop_headers, nil, {})
            assert.are_same(1, #result.finished_spans)
            assert.are_same(make_propagation_headers(result.request_span, "unsampled"), result.req_headers_added)

            for _, v in ipairs(result.finished_spans) do
                assert.is_false(v:context():is_sampled())
            end
            assert.are_same({}, result.resp_headers_added)
        end)
    end)
end)

describe("sending traceresponse", function()
    it("injects response header when configured", function()
        local config = test_utils.make_config({  plugin_open_telemetry_set_traceresponse = true })
        local trace_id = "11111111d5838de2663cac10341d89bb"
        local new_span_context = span_context.new(trace_id, "30e2bb20d2ad42b9", nil, nil, false)
        local span = recording_span.new(nil, nil, new_span_context, "test_span", {})
        local propagation_headers = make_propagation_headers(span, "sampled")
        local result = simulate_request(config, propagation_headers, nil)
        local request_span = span_by_name("nginx.request", result.finished_spans)
        assert.are_same(
            result.resp_headers_added.traceresponse,
            "00-" .. request_span:context().trace_id .. "-" .. request_span:context().span_id .. "-1") -- TODO: fix the code so that this returns -01
    end)

    it("does not inject http header when not configured", function()
        local config = test_utils.make_config({  plugin_open_telemetry_set_traceresponse = false })
        local result = simulate_request(config, {}, nil)
        assert.are.same(result.resp_headers_added, {})
    end)
end)
