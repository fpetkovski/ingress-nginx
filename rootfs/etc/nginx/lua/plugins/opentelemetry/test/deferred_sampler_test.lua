local context = require "opentelemetry.context"
local ds = require "plugins.opentelemetry.deferred_sampler"
local result = require "opentelemetry.trace.sampling.result"
local recording_span = require("opentelemetry.trace.recording_span")
local span_context = require "opentelemetry.trace.span_context"
local span_kind = require("opentelemetry.trace.span_kind")
local tracestate = require("opentelemetry.trace.tracestate")

describe("should_sample", function()
    it("returns RECORD_ONLY when parent context is empty", function()
        local s = ds.new()
        local ts = tracestate.new({ foo = "bar" })
        local new_span_context = span_context.new("malformed", "30e2bb20d2ad42b9", nil, ts, false)
        local span = recording_span.new(nil, nil, new_span_context, "test_span", { kind = span_kind.server })
        local ctx = context.new({}, span)
        local r = s:should_sample({ parent_ctx = ctx })
        assert.are.same(r.decision, result.record_only)
        assert.are.same(r.trace_state, ts)
    end)

    it("returns RECORD_AND_SAMPLE when parent context is sampled", function()
        local s = ds.new()
        local ts = tracestate.new({ foo = "bar" })
        local new_span_context = span_context.new("malformed", "30e2bb20d2ad42b9", 1, ts, false)
        local span = recording_span.new(nil, nil, new_span_context, "test_span", { kind = span_kind.server })
        local ctx = context.new({}, span)
        local r = s:should_sample({ parent_ctx = ctx })
        assert.are.same(r.decision, result.record_and_sample)
        assert.are.same(r.trace_state, ts)
    end)

    it("returns RECORD_ONLY when parent context is not sampled", function()
        local s = ds.new()
        local ts = tracestate.new({ foo = "bar" })
        local new_span_context = span_context.new("malformed", "30e2bb20d2ad42b9", 0, ts, false)
        local span = recording_span.new(nil, nil, new_span_context, "test_span", { kind = span_kind.server })
        local ctx = context.new({}, span)
        local r = s:should_sample({ parent_ctx = ctx })
        assert.are.same(r.decision, result.record_only)
        assert.are.same(r.trace_state, ts)
    end)
end)
